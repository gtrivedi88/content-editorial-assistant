"""
Negative Example Validator
Validates whether detected errors should be flagged based on contextual appropriateness.
Uses negative example patterns to reduce false positives.
"""

import logging
from typing import Dict, List, Any, Optional
from .multi_pass.base_validator import (
    BasePassValidator, 
    ValidationContext, 
    ValidationResult, 
    ValidationConfidence,
    ValidationDecision
)

logger = logging.getLogger(__name__)


class NegativeExampleValidator(BasePassValidator):
    """
    Validator that checks if detected errors are actually appropriate in context.
    Uses negative example patterns to identify when rules shouldn't apply.
    """
    
    def __init__(self):
        super().__init__(
            validator_name="negative_example_validator",
            enable_performance_tracking=True,
            min_confidence_threshold=0.7
        )
        self.negative_patterns = self._load_negative_patterns()
        self.priority = 1000  # Run last - higher priority means later execution
    
    def _load_negative_patterns(self) -> Dict[str, List[str]]:
        """Load negative example patterns from configuration."""
        return {
            'passive_voice': [
                'was corrupted during', 'was designed to', 'are performed automatically',
                'was completed', 'is processed by', 'was interrupted by',
                'are generated by', 'is handled by'
            ],
            'word_usage': [
                'simple solution for', 'click the download', 'just enter your',
                'simply click to', 'easily configure'
            ],
            'contractions': [
                "we're here to help", "don't forget to", "it's working as expected",
                "you're able to", "can't be modified"
            ],
            'second_person': [
                'you can customize your', 'your data will be', 'if you encounter this error',
                'your session has expired', 'you need to verify'
            ],
            'tone': [
                'absolutely critical for security', 'must complete this task',
                'cannot be ignored', 'extremely important', 'vital that you',
                'this is critical!', 'amazing! your setup'
            ],
            'technical_formatting': [
                '/etc/', '/var/log/', 'C:\\Program Files', '~/.config',
                'configure settings >', 'press ctrl+c'
            ],
            'sentence_length': [
                'to configure the advanced', 'including two-factor authentication',
                'navigate to the security panel'
            ],
            'claims': [
                'best approach for security', 'guarantees 99.99% uptime',
                'easiest method for', 'our platform guarantees'
            ],
            'legal_company_names': [
                'install docker and', 'compatible with mysql',
                'postgresql, and oracle', 'educational tutorial'
            ],
            'currency': [
                'license costs $99', 'budget approximately $',
                'domestic pricing', '$500-$1000'
            ],
            'ambiguity': [
                'various data types', 'configure the settings as needed',
                'marketing overview', 'for your environment'
            ],
            'anthropomorphism': [
                'system wants you to', 'application is smart enough',
                'user_facing_message', 'detect conflicts automatically'
            ],
            'inclusive_language': [
                'founding fathers established', 'man-hours to implement',
                'historical reference', 'industry standard term'
            ],
            'numbers': [
                '5,000,000 records', 'file is 2kb in size',
                'precise technical spec', 'technical measurement'
            ],
            'punctuation': [
                'warning: this is critical!', 'settings > advanced >',
                'urgent alert', 'navigation path'
            ],
            'lists': [
                'valid license;', 'network access;', 'admin rights.',
                'quick steps: 1) login 2)'
            ],
            'references': [
                'see the documentation for more',
                'click here to download',
                'brief reference', 'inline link'
            ]
        }
    
    def _validate_error(self, context: ValidationContext) -> ValidationResult:
        """
        Validate if the error should be flagged given contextual appropriateness.
        
        Args:
            context: Validation context with error details
            
        Returns:
            ValidationResult indicating if error should be suppressed
        """
        try:
            # Check if this error type has negative example patterns
            error_type = self._normalize_error_type(context.rule_type)
            if error_type not in self.negative_patterns:
                # No negative patterns for this rule type - proceed with flagging
                return ValidationResult(
                    decision=ValidationDecision.ACCEPT,  # Accept the error (flag it)
                    confidence=ValidationConfidence.MEDIUM,
                    message="No negative example patterns for this rule type",
                    evidence=None,
                    processing_time=0.0,
                    details={'pattern_matching': 'not_applicable'}
                )
            
            # Check for negative example patterns in context
            appropriateness_analysis = self._analyze_contextual_appropriateness(
                context.text, context.rule_type, context.flagged_text
            )
            
            if appropriateness_analysis['is_appropriate']:
                # Error appears in appropriate context - suppress flagging
                return ValidationResult(
                    decision=ValidationDecision.REJECT,  # Reject the error (don't flag it)
                    confidence=ValidationConfidence.HIGH,
                    message=f"Rule violation appropriate in context: {appropriateness_analysis['reason']}",
                    evidence=None,  # No evidence needed for rejection
                    processing_time=0.0,
                    details={
                        'suppression_reason': appropriateness_analysis['reason'],
                        'patterns_matched': appropriateness_analysis['patterns_matched'],
                        'negative_example_applied': True
                    }
                )
            else:
                # No contextual appropriateness found - proceed with flagging
                return ValidationResult(
                    decision=ValidationDecision.ACCEPT,  # Accept the error (flag it)
                    confidence=ValidationConfidence.MEDIUM,
                    message="No contextual appropriateness patterns detected",
                    evidence=None,
                    processing_time=0.0,
                    details={
                        'patterns_checked': len(self.negative_patterns[error_type]),
                        'negative_example_applied': False
                    }
                )
                
        except Exception as e:
            logger.error(f"Error in negative example validation: {e}")
            # If validation fails, err on the side of flagging the error
            return ValidationResult(
                decision=ValidationDecision.ACCEPT,  # Accept the error (flag it)
                confidence=ValidationConfidence.LOW,
                message=f"Validation error: {str(e)}",
                evidence=None,
                processing_time=0.0,
                details={'error': str(e)}
            )
    
    def _normalize_error_type(self, rule_type: Optional[str]) -> str:
        """Normalize rule type to match negative pattern categories."""
        if not rule_type:
            return 'unknown'
        
        rule_type_lower = rule_type.lower()
        
        # Map rule types to negative pattern categories
        if 'passive' in rule_type_lower or 'voice' in rule_type_lower:
            return 'passive_voice'
        elif 'word_usage' in rule_type_lower:
            return 'word_usage'
        elif 'contraction' in rule_type_lower:
            return 'contractions'
        elif 'second_person' in rule_type_lower:
            return 'second_person'
        elif 'tone' in rule_type_lower:
            return 'tone'
        elif 'technical' in rule_type_lower:
            return 'technical_formatting'
        elif 'sentence_length' in rule_type_lower:
            return 'sentence_length'
        elif 'claim' in rule_type_lower or 'legal_claim' in rule_type_lower:
            return 'claims'
        elif 'company_name' in rule_type_lower or 'trademark' in rule_type_lower:
            return 'legal_company_names'
        elif 'currency' in rule_type_lower:
            return 'currency'
        elif 'ambiguity' in rule_type_lower:
            return 'ambiguity'
        elif 'anthropomorphism' in rule_type_lower:
            return 'anthropomorphism'
        elif 'inclusive' in rule_type_lower or 'gendered' in rule_type_lower:
            return 'inclusive_language'
        elif 'number' in rule_type_lower or 'measurement' in rule_type_lower:
            return 'numbers'
        elif 'punctuation' in rule_type_lower or 'comma' in rule_type_lower or 'exclamation' in rule_type_lower:
            return 'punctuation'
        elif 'list' in rule_type_lower or 'procedure' in rule_type_lower:
            return 'lists'
        elif 'reference' in rule_type_lower or 'citation' in rule_type_lower:
            return 'references'
        else:
            return rule_type_lower
    
    def _analyze_contextual_appropriateness(self, text: str, rule_type: Optional[str], 
                                          flagged_text: Optional[str]) -> Dict[str, Any]:
        """
        Analyze if the detected error is contextually appropriate.
        
        Args:
            text: Full text context
            rule_type: Type of rule that flagged the error
            flagged_text: Specific text that was flagged
            
        Returns:
            Dictionary with appropriateness analysis
        """
        error_type = self._normalize_error_type(rule_type)
        patterns = self.negative_patterns.get(error_type, [])
        
        text_lower = text.lower()
        patterns_matched = []
        
        # Check for negative example patterns
        for pattern in patterns:
            if pattern in text_lower:
                patterns_matched.append(pattern)
        
        is_appropriate = len(patterns_matched) > 0
        
        # Generate contextual reason
        reason = ""
        if is_appropriate:
            if error_type == 'passive_voice':
                reason = "Passive voice appropriate for system/automated processes or unknown actors"
            elif error_type == 'word_usage':
                reason = "Word usage appropriate for UI instructions or comparative contexts"
            elif error_type == 'contractions':
                reason = "Contractions appropriate for friendly, supportive tone"
            elif error_type == 'second_person':
                reason = "Second person necessary for user-specific instructions and data references"
            elif error_type == 'tone':
                reason = "Strong tone appropriate for security warnings and critical instructions"
            elif error_type == 'technical_formatting':
                reason = "Informal technical formatting appropriate for conversational support"
            elif error_type == 'sentence_length':
                reason = "Complex sentence appropriate for comprehensive instructions"
            elif error_type == 'claims':
                reason = "Claims appropriate when backed by compliance standards or formal commitments"
            elif error_type == 'legal_company_names':
                reason = "Company names without trademarks appropriate in educational/fair use contexts"
            elif error_type == 'currency':
                reason = "Currency symbols appropriate in domestic pricing and informal contexts"
            elif error_type == 'ambiguity':
                reason = "General language appropriate in overview contexts and flexible guidance"
            elif error_type == 'anthropomorphism':
                reason = "Personification appropriate for user-facing messages and feature marketing"
            elif error_type == 'inclusive_language':
                reason = "Traditional terms appropriate in historical references and standard terminology"
            elif error_type == 'numbers':
                reason = "Number formatting appropriate for technical specifications and measurements"
            elif error_type == 'punctuation':
                reason = "Punctuation variation appropriate for emphasis and navigation contexts"
            elif error_type == 'lists':
                reason = "List formatting appropriate for formal specifications and quick reference"
            elif error_type == 'references':
                reason = "General references appropriate when specific details vary by user context"
            else:
                reason = f"Pattern suggests {error_type} is contextually appropriate"
        
        return {
            'is_appropriate': is_appropriate,
            'reason': reason,
            'patterns_matched': patterns_matched,
            'patterns_checked': len(patterns)
        }
    
    def get_validator_info(self) -> Dict[str, Any]:
        """Get information about this validator."""
        return {
            'name': self.validator_name,
            'type': 'negative_example_validator',
            'priority': self.priority,
            'patterns_loaded': {rule_type: len(patterns) for rule_type, patterns in self.negative_patterns.items()},
            'total_patterns': sum(len(patterns) for patterns in self.negative_patterns.values()),
            'purpose': 'Reduces false positives by identifying contextually appropriate rule violations'
        }
    
    def validate_error(self, context: ValidationContext) -> ValidationResult:
        """
        Public interface for validating errors.
        Wraps the abstract _validate_error method with performance tracking.
        """
        return self._validate_error(context)
